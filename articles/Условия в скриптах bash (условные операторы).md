# Условия в скриптах bash (условные операторы)

## Вступление

В Bash имеется множество встроенных проверок и сравнений, что очень удобно во многих ситуациях. Вы, наверное, видели, если такие заявления раньше:

```bash
if [ $foo -ge 3 ]; then
```

Условие в этом примере по сути является командой. Это может звучать странно, но сравнение с квадратными скобками аналогично использованию встроенной команды `test`, например:

```bash
if test $foo -ge 3; then
```

Если $foo больше(G) или равно(E) 3, блок после «then» будет выполнен. Если вы всегда задавались вопросом, почему bash использует `-ge` или `-eq` вместо >= или ==, это потому, что этот тип условия исходит из команды, где `-ge` и `-eq` - параметры.
И это то, что по сути, проверяет состояние завершения команды. Я объясню это более подробно далее в руководстве.
Также есть встроенные проверки, которые более специфичны для оболочек.

```bash
if [ -f regularfile ]; then
```

Вышеуказанное условие выполняется, если файл «regularfile» существует _и_
это обычный файл. Обычный файл означает, что это не блок или
символьное устройство или каталог. Таким образом, вы можете быть уверены, что
Файл существует, прежде чем что-то делать с ним. Вы даже можете проверить, если
файл читабелен!

```bash
if [ -r readablefile]; then
```

Приведенное выше условие выполняется, если файл «readablefile» существует и доступен для чтения. Легко, не правда ли?

## Синтаксис оператора if (краткое объяснение)

Основной синтаксис оператора _if … then_ выглядит следующим образом:

```bash
if <condition>; then
<commands>
fi
```

Условие, в зависимости от его типа, окружено определенным
скобки, например. \[\]. Вы можете прочитать о различных типах дальше
в учебнике. Вы можете добавить команды, которые будут выполняться, когда условие ложно, с помощью ключевого слова _else_ и использовать ключевое слово _elif_ (elseif) для выполнения команд с другим условием, если основное условие ложно. Ключевое слово _else_ всегда стоит последним. Пример:

```bash
if [ -r somefile ]; then
        content=$(cat somefile)
elif [ -f somefile ]; then
        echo "The file 'somefile' exists but is not readable to the script."
else
        echo "The file 'somefile' does not exist."
fi
```

Краткое объяснение примера: сначала мы проверяем, является ли файл somefile читаемым («if \[-r somefile \]»). Если так, мы читаем это в переменную. Если нет, мы проверяем, существует ли он на самом деле («elif \[-f somefile \]»). Если это правда, мы сообщаем, что он существует, но не читается (если бы это было так, мы бы прочитали содержимое). Если файл не существует, мы также сообщаем об этом. Условие в _elif_ выполняется только в том случае, если условие в _if_ было ложным. Команды, принадлежащие _else_, выполняются, только если оба условия ложны.

## Основные правила условий

Когда вы начинаете писать и использовать свои собственные условия, вы должны знать некоторые правила, чтобы избежать ошибок, которые трудно отследить. Вот три важных:

1.  **Всегда оставляйте пробелы между скобками и фактической проверкой/сравнением**. Следующие не будут работать:
    
    ```bash
    if [$foo -ge 3]; then
    ```
    
    Баш будет жаловаться на “отсутствуoщий '\]'”.
    
2.  **Всегда заканчивайте строку перед введением нового ключевого слова, такого как «then»**. Слова _if_, _then_, _else_, _elif_ и _fi_ являются ключевыми словами оболочки, что означает, что они не могут использовать одну и ту же строку. Поместите «;» между предыдущим оператором и ключевым словом или поместите ключевое слово в начале новой строки. Bash будет выдавать ошибки, такие как «ошибка синтаксиса, рядом с неожиданным токеном «fi», если вы этого не сделаете.
3.  _Это хорошая привычка заключать в кавычки строковые переменные, если вы используете их в условиях_, потому что в противном случае они могут создать проблемы, если они содержат пробелы и/или символы новой строки. Цитируя я имею в виду:
    
    ```bash
    if [ "$stringvar" == "tux" ]; then
    ```
    
    Есть несколько случаев, в которых вы не должны экранировать ковычками, но они редки. Вы увидите одну из них далее в руководстве.
    

Кроме того, есть две вещи, которые может быть полезно знать:

1.  _Вы можете инвертировать условие_, поставив перед ним «!». Пример:
    
    ```bash
    if [ ! -f regularfile ]; then
    ```
    
    Обязательно поместите "!" В скобки!
    
2.  _Вы можете комбинировать условия_ с помощью определенных операторов. Для синтаксиса с одной скобкой, который мы использовали до сих пор, вы можете использовать «-a» для _and_ и «-o» для _or_. Пример:
    
    ```bash
    if [ $foo -ge 3 -a $foo -lt 10 ]; then
    ```
    
    Приведенное выше условие вернет true, если $foo содержит целое число, большее или равное 3 и меньшее (**L**ess **T**han) 10. Подробнее об этих выражениях объединения можно прочитать в соответствующих синтаксисах условий.
    

И еще одна базовая вещь: не забывайте, что условия могут также использоваться в других операторах, таких как _while_ и _until_. Объяснение этого не входит в этот урок, но вы можете прочитать о них в [Руководстве по Bash для начинающих](http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html.).

Во всяком случае, я пока показал вам только условия в одинарных скобках. Однако есть и другие синтаксисы, о которых вы узнаете в следующем разделе.

## Различные синтаксисы условий

Bash имеет различные синтаксисы для условий. Я перечислю три из них:

### 1. Синтаксис с одной скобкой

Это синтаксис условия, который вы уже видели в предыдущих параграфах; это самый старый поддерживаемый синтаксис. Он поддерживает три типа условий:

*   **Файловые условия**
    *   Позволяет различные виды проверок. Пример:
        
        ```bash
        if [ -L symboliclink ]; then
        ```
        
        Приведенное выше условие верно, если файл символическая ссылка существует и является символической ссылкой. Дополнительные условия для файлов см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#file-based-conditions) ниже.
        
*   **Строковые условия**
    *   Позволяет проверять строку и сравнивать строки. Пример первый:
        
        ```bash
        if [ -z "$emptystring" ]; then
        ```
        
        Вышеуказанное условие истинно, если $emptystring является пустой строкой или неинициализированной переменной. Пример два:
        
        ```bash
        if [ "$stringvar1" == "cheese" ]; then
        ```
        
        Приведенное выше условие истинно, если $stringvar1 содержит только строку «cheese». Дополнительные условия на основе строк см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#string-based-conditions) ниже.
        
*   **Арифметические (числовые) условия**
    *   Позволяет сравнивать целые числа. Пример:
        
        ```bash
        if [ $num -lt 1 ]; then
        ```
        
        Приведенное выше условие возвращает true, если $num меньше 1. Более подробные арифметические условия см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#arithmetic-conditions) ниже.
        

### 2. Синтаксис в двойных скобках

Возможно, вы уже столкнулись с условиями, заключенными в двойные квадратные скобки, которые выглядят так:

```bash
if [[ "$stringvar" == *string* ]]; then
```

Синтаксис двойной скобки служит расширенной версией синтаксиса одной скобки; он в основном имеет те же особенности, но и некоторые важные различия с ним. Я перечислю их здесь:

*   Первое отличие_ можно увидеть в приведенном выше примере; при сравнении строк в синтаксисе двойных скобок используется глобализация оболочки(shell globbing). Это означает, что звездочка («\*») расширится буквально до чего угодно, как вы, вероятно, знаете из обычного использования командной строки. Поэтому, если $stringvar где-либо содержит фразу «string», условие вернет true. Допускаются и другие формы срыва оболочки. Если вы хотите сопоставить и строку «String», и строку «string», вы можете использовать следующий синтаксис:
    
    ```bash
    if [[ "$stringvar" == *[sS]tring* ]]; then
    ```
    
    Обратите внимание, что допускается только общее глобирование оболочки. Такие Bash-специфичные вещи, такие как {1..4} или {foo, bar}, не будут работать. Также обратите внимание, что **глобирование не будет работать, если вы экранировали кавычками правую строку**. В этом случае вы должны оставить его без кавычек.
    
*   Второе отличие - это то, что разделение слов предотвращено. Следовательно, вы можете опустить размещение кавычек вокруг строковых переменных и без проблем использовать условие, подобное следующему:
    
    ```bash
    if [[ $stringvarwithspaces != foo ]]; then
    ```
    
    Тем не менее, цитирование строковых переменных остается хорошей привычкой, поэтому я рекомендую просто продолжать это делать.
    
*   Третье отличие состоит в том, что имена файлов не расширяются. Я проиллюстрирую это различие на двух примерах, начиная со старой ситуации с одной скобкой:
    
    ```bash
    if [ -a *.sh ]; then
    ```
    
    Вышеуказанное условие вернет true, если в рабочем каталоге есть один файл с расширением .sh. Если их нет, он вернет false. Если есть несколько файлов .sh, bash выдаст ошибку и прекратит выполнение скрипта. Это связано с тем, что \*.sh распространяется на файлы в рабочем каталоге. Использование двойных скобок предотвращает это:
    
    ```bash
    if [[ -a *.sh ]]; then
    ```
    
    Приведенное выше условие вернет true, только если в рабочем каталоге есть файл с именем «\*.sh», независимо от того, какие существуют другие файлы .sh. Звездочка взята буквально, потому что синтаксис в двойных скобках не расширяет имена файлов.
    
*   Четвертое отличие - это добавление более общеизвестных объединяющих выражений или, более конкретно, операторов «&&» и «||». Пример:
    
    ```bash
    if [[ $num -eq 3 && "$stringvar" == foo ]]; then
    ```
    
    Приведенное выше условие возвращает true, если $num равно 3, а $stringvar равно «foo». Также поддерживаются -a и -o, известные из синтаксиса с одной скобкой.
    
    Обратите внимание, что оператор _and_ имеет приоритет над оператором _or_, что означает, что «&&» или «-a» будет оцениваться перед «||» или «-о».
    
*   Пятое отличие состоит в том, что синтаксис в двойных скобках позволяет сопоставлять шаблоны с помощью оператора «=\~». Смотрите [таблица](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#string-based-conditions) для получения дополнительной информации.

### 3. Синтаксис с двойными скобками

Существует также другой синтаксис для арифметических (основанных на числах) условий, наиболее вероятно взятый из оболочки Korn:

```bash
if (( $num <= 5 )); then
```

Приведенное выше условие выполняется, если $num меньше или равно 5. Этот синтаксис может показаться программистам более знакомым. Он включает в себя все "нормальные" операторы, такие как ==, <-> и =>. Он поддерживает комбинирующие выражения «&&» и «||» (но не выражения -a и -o!). Это эквивалентно встроенной команде let.

## Таблица условий

В следующей таблице перечислены возможные условия для синтаксиса с одинарными и двойными скобками. За исключением одного исключения, примеры приведены в синтаксисе с одинарными скобками, но всегда совместимы с двойными скобками.

<table style="box-sizing: inherit; border-spacing: 0px; border-collapse: collapse; background-color: rgb(255, 255, 255); margin: 0px 0px 1.5em; width: 740px; color: rgb(51, 51, 51); font-family: omnes-pro, Omnes, Helvetica, Arial, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><tbody style="box-sizing: inherit;"><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="file-based-conditions" name="file-based-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;1. File-based conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -a existingfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘existingfile’ exists.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -a tmp.tmp ]; then<br style="box-sizing: inherit;">rm -f tmp.tmp #<span>&nbsp;</span><em style="box-sizing: inherit; font-style: italic;">Make sure we’re not bothered by an old temporary file<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -b blockspecialfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘blockspecialfile’ exists and is block special.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Block special files are special kernel files found in /dev, mainly used for ATA devices like hard disks, cd-roms and floppy disks.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -b /dev/fd0 ]; then<br style="box-sizing: inherit;">dd if=floppy.img of=/dev/fd0 #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Write an image to a floppy</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -c characterspecialfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘characterspecialfile’ exists and is character special.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Character special files are special kernel files found in /dev, used for all kinds of purposes (audio hardware, tty’s, but also /dev/null).<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -c /dev/dsp ]; then<br style="box-sizing: inherit;">cat raw.wav &gt; /dev/dsp #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This actually works for certain raw wav files</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -d directory ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘directory’ exists and is a directory.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">In UNIX-style, directories are a special kind of file.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -d ~/.kde ]; then<br style="box-sizing: inherit;">echo “You seem to be a kde user.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -e existingfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘existingfile’ exists.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">(same as -a, see that entry for an example)</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -f regularfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘regularfile’ exists and is a regular file.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A regular file is neither a block or character special file nor a directory.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -f ~/.bashrc ]; then<br style="box-sizing: inherit;">source ~/.bashrc<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -g sgidfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘sgidfile’ exists and is set-group-ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">When the SGID-bit is set on a directory, all files created in that directory will inherit the group of the directory.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -g . ]; then<br style="box-sizing: inherit;">echo “Created files are inheriting the group ‘$(ls -ld . | awk ‘{ print $4 }’)’ from the working directory.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -G fileownedbyeffectivegroup ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘fileownedbyeffectivegroup’ exists and is owned by the effective group ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The effective group id is the primary group id of the executing user.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -G file ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">chgrp $(id -g) file #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Change the group if it’s not the effective one</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -h symboliclink ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘symboliclink’ exists and is a symbolic link.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -h $pathtofile ]; then<br style="box-sizing: inherit;">pathtofile=$(readlink -e $pathtofile) #<em style="box-sizing: inherit; font-style: italic;">Make sure $pathtofile contains the actual file and not a symlink to it</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -k stickyfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘stickyfile’ exists and has its sticky bit set.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The sticky bit has got<span>&nbsp;</span><a title="Read about the sticky bit on Wikipedia" href="http://en.wikipedia.org/wiki/Sticky_bit" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">quite a history</a>, but is now used to prevent world-writable directories from having their contents deletable by anyone.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -k /tmp ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">echo “Warning! Anyone can delete and/or rename your files in /tmp!”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -L symboliclink ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘symboliclink’ exists and is a symbolic link.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">(same as -h, see that entry for an example)</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -N modifiedsincelastread ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘modifiedsincelastread’ exists and was modified after the last read.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -N /etc/crontab ]; then<br style="box-sizing: inherit;">killall -HUP crond #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>SIGHUP makes crond reread all crontabs<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -O fileownedbyeffectiveuser ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘fileownedbyeffectiveuser’ exists and is owned by the user executing the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -O file ]; then<br style="box-sizing: inherit;">chmod 600 file #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Makes the file private, which is a bad idea if you don’t own it</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -p namedpipe ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘namedpipe’ exists and is a named pipe.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A named pipe is a file in /dev/fd/ that can be read just once. See<span>&nbsp;</span><a title="See a way of using a named pipe in my bash tutorial" href="http://www.linuxtutorialblog.com/post/tutorial-the-best-tips-tricks-for-bash#using-several-ways-of-substitution" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">my bash tutorial</a><span>&nbsp;</span>for a case in which it’s used.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -p $file ]; then<br style="box-sizing: inherit;">cp $file tmp.tmp #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Make sure we’ll be able to read</em><br style="box-sizing: inherit;">file=”tmp.tmp”&nbsp;&nbsp;&nbsp; #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>the file as many times as we like</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -r readablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘readablefile’ exists and is readable to the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [-r file ]; then<br style="box-sizing: inherit;">content=$(cat file) #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Set $content to the content of the file<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -s nonemptyfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘nonemptyfile’ exists and has a size of more than 0 bytes.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -s logfile ]; then<br style="box-sizing: inherit;">gzip logfile&nbsp;&nbsp;&nbsp; #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Backup the old logfile</em><br style="box-sizing: inherit;">touch logfile #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>before creating a fresh one.</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -S socket ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘socket’ exists and is a socket.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A socket file is used for inter-process communication, and features an interface similar to a network connection.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -S /var/lib/mysql/mysql.sock ]; then<br style="box-sizing: inherit;">mysql –socket=/var/lib/mysql/mysql.sock #<em style="box-sizing: inherit; font-style: italic;">See<span>&nbsp;</span><a title="MySQL socket in non-default place" href="http://www.tech-recipes.com/mysql_tips762.html" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">this MySQL tip</a><br style="box-sizing: inherit;"></em>fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -t openterminal ]</td><td style="box-sizing: inherit; padding: 0.4em;">file descriptor ‘openterminal’ exists and refers to an open terminal.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Virtually everything is done using files on Linux/UNIX, and the terminal is no exception.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -t /dev/pts/3 ]; then<br style="box-sizing: inherit;">echo -e “nHello there. Message from terminal $(tty) to you.” &gt; /dev/pts/3 #<em style="box-sizing: inherit; font-style: italic;">Anyone using that terminal will actually see this message!</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -u suidfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘suidfile’ exists and is set-user-ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Setting the suid-bit on a file causes execution of that file to be done with the credentials of the owner of the file, not of the executing user.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -u executable ]; then<br style="box-sizing: inherit;">echo “Running program executable as user $(ls -l executable | awk ‘{ print $3 }’).”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -w writeablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘writeablefile’ exists and is writeable to the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -w /dev/hda ]; then<br style="box-sizing: inherit;">grub-install /dev/hda<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -x executablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘executablefile’ exists and is executable for the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Note that the execute permission on a directory means that it’s searchable (you can see which files it contains).<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -x /root ]; then<br style="box-sizing: inherit;">echo “You can view the contents of the /root directory.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ newerfile -nt olderfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘newerfile’ was changed more recently than ‘olderfile’, or if ‘newerfile’ exists and ‘olderfile’ doesn’t.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ story.txt1 -nt story.txt ]; then<br style="box-sizing: inherit;">echo “story.txt1 is newer than story.txt; I suggest continuing with the former.”<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ olderfile -ot newerfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘olderfile’ was changed longer ago than ‘newerfile’, or if ‘newerfile’ exists and ‘olderfile’ doesn’t.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ /mnt/remote/remotefile -ot localfile ]; then<br style="box-sizing: inherit;">cp -f localfile /mnt/remote/remotefile #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Make sure the remote location has the newest version of the file, too</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ same -ef file ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘same’ and file ‘file’ refer to the same device/inode number.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ /dev/cdrom -ef /dev/dvd ]; then<br style="box-sizing: inherit;">echo “Your primary cd drive appears to read dvd’s, too.”<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="string-based-conditions" name="string-based-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;2. String-based conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 == STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 is equal to STRING2.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ “$1” == “moo” ]; then<br style="box-sizing: inherit;">echo $cow #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Ever tried executing ‘apt-get moo’?<br style="box-sizing: inherit;"></em>fiNote: you can also use a single “=” instead of a double one.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 != STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 is not equal to STRING2.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ “$userinput” != “$password” ]; then<br style="box-sizing: inherit;">echo “Access denied! Wrong password!”<br style="box-sizing: inherit;">exit 1 #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Stops script execution right here</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 &gt; STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 sorts after STRING2 in the current locale (lexographically).</td><td rowspan="2" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The backslash before the angle bracket is there because the bracket needs to be escaped to be interpreted correctly. As an example we have a basic<span>&nbsp;</span><a title="What is a bubble sort? See wikipedia!" href="http://en.wikipedia.org/wiki/Sorting_algorithm#Bubble_sort" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">bubble sort</a>:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"><em style="box-sizing: inherit; font-style: italic;">(Don’t feel ashamed if you don’t understand this, it is a more complex example)</em></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">array=( linux tutorial blog )<br style="box-sizing: inherit;">swaps=1<br style="box-sizing: inherit;">while (( swaps &gt; 0 )); do</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">swaps=0<br style="box-sizing: inherit;">for (( i=0; i &lt; (( ${#array[@]} – 1 )) ; i++ )); do<br style="box-sizing: inherit;">if [ “${array[$i]}” &gt; “${array[$(( i + 1 ))]}” ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Here is the sorting condition</em><br style="box-sizing: inherit;">tempstring=${array[$i]}<br style="box-sizing: inherit;">array[$i]=${array[$(( i + 1 ))]}<br style="box-sizing: inherit;">array[$(( i + 1 ))]=$tempstring<br style="box-sizing: inherit;">(( swaps=swaps + 1 ))<br style="box-sizing: inherit;">fi<br style="box-sizing: inherit;">done<br style="box-sizing: inherit;">done<br style="box-sizing: inherit;">echo ${array[@]} #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Returns “blog linux tutorial”</em></p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 &lt; STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">STRING1 sorts before STRING2 in the current locale (lexographically).</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -n NONEMPTYSTRING ]</td><td style="box-sizing: inherit; padding: 0.4em;">NONEMPTYSTRING has a length of more than zero.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">This condition only accepts valid strings, so be sure to quote anything you give to it.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -n “$userinput” ]; then<br style="box-sizing: inherit;">userinput=parse($userinput) #<span>&nbsp;</span><em style="box-sizing: inherit; font-style: italic;">Only parse if the user actually gave some input.</em><br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">Note that you can also omit the “-n”, as brackets with just a string in it behave the same.</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -z EMPTYSTRING ]</td><td style="box-sizing: inherit; padding: 0.4em;">EMPTYSTRING is an empty string.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">This condition also accepts non-string input, like an uninitialized variable:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -z $uninitializedvar ]; then<br style="box-sizing: inherit;">uninitializedvar=”initialized” #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>-z returns true on an uninitialized variable, so we initialize it here.</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;"><em style="box-sizing: inherit; font-style: italic;">Double-bracket syntax only:<br style="box-sizing: inherit;"></em>[[ STRING1 =~ REGEXPATTERN ]]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 matches REGEXPATTERN.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">If you are familiar with Regular Expressions, you can use this conditions to perform a regex match.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [[ “$email” =~ “b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,4}b” ]]; then<br style="box-sizing: inherit;">echo “$email contains a valid e-mail address.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="arithmetic-conditions" name="arithmetic-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;3. Arithmetic (number-based) conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -eq NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">EQ</strong>ual to NUM2.</td><td rowspan="6" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $? -eq 0 ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>$? returns the exit status of the previous command</em><br style="box-sizing: inherit;">echo “Previous command ran succesfully.”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $(ps -p $pid -o ni=) -ne $(nice) ]; then<br style="box-sizing: inherit;">echo “Process $pid is running with a non-default nice value”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $num -lt 0 ]; then<br style="box-sizing: inherit;">echo “Negative numbers not allowed; exiting…”<br style="box-sizing: inherit;">exit 1<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -ne NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">N</strong>ot<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -gt NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">G</strong>reater<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">T</strong>han NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -ge NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">G</strong>reater than or<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -lt NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">L</strong>ess<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">T</strong>han NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -le NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">L</strong>ess than or<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="miscellaneous-conditions" name="miscellaneous-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>4. Miscellaneous conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -o shelloption ]</td><td style="box-sizing: inherit; padding: 0.4em;">shell option ‘shelloption’ is enabled.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Shell options modify the behaviour of bash, except a few unmodifiable ones that indicate the shell status.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -o checkwinsize ] #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">echo “Shell option checkwinsize is disabled; enabling it so you can resize you terminal window without problems.”<br style="box-sizing: inherit;">shopt -s checkwinsize #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This shell option is modifiable</em><br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -o login_shell ]; then<br style="box-sizing: inherit;">echo “This a a login shell.” #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This shell option is not modifiable<br style="box-sizing: inherit;"></em><br style="box-sizing: inherit;">fi</p></td></tr></tbody></table>

С помощью синтаксиса с двойными круглыми скобками вы можете использовать следующие условия:

<table style="box-sizing: inherit; border-spacing: 0px; border-collapse: collapse; background-color: rgb(255, 255, 255); margin: 0px 0px 1.5em; width: 740px; color: rgb(51, 51, 51); font-family: omnes-pro, Omnes, Helvetica, Arial, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><tbody style="box-sizing: inherit;"><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="double-parenthesis-syntax-conditions" name="double-parenthesis-syntax-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>5. Double-parenthesis syntax conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 == NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em;">NUM1 is equal to NUM2.</td><td rowspan="6" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $? == 0 )); then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>$? returns the exit status of the previous command</em><br style="box-sizing: inherit;">echo “Previous command ran succesfully.”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $(ps -p $pid -o ni=) != $(nice) )); then<br style="box-sizing: inherit;">echo “Process $pid is running with a non-default nice value”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $num &lt; 0 )); then<br style="box-sizing: inherit;">echo “Negative numbers not allowed; exiting…”<br style="box-sizing: inherit;">exit 1<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 != NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is not equal to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &gt; NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is greater than NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &gt;= NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is greater than or equal to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &lt; NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is less than NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &lt;= NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is less than or&nbsp;equal to NUM2.</td></tr></tbody></table>

После этой сухой информационной нагрузки, здесь есть небольшое объяснение для тех, кто хочет узнать больше ...

## Погружение немного глубже

Я сказал, что расскажу больше о том, что _if_ по существу проверяет состояние завершения команд. И я так и сделаю. Основное правило bash, когда дело доходит до условий: 0 равно true, >0 равно false.
Это в значительной степени противоположно многим языкам программирования, где 0 равно false, а 1 (или более) равно true. Причиной этого является то, что оболочки типа bash часто работают с программами. По соглашению UNIX программы используют состояние выхода для указания того, что выполнение прошло нормально или произошла ошибка. Поскольку успешное выполнение не требует каких-либо объяснений, ему нужен только один статус выхода. Однако, если возникла проблема, полезно знать, что пошло не так. Следовательно, 0 используется для успешного выполнения, а 1-255 для указания, какая ошибка произошла. Значения чисел 1-255 различаются в зависимости от программы, возвращающей их.

В любом случае, _if_ выполняет блок после _then_, когда команда возвращает 0. Да, условия являются командами. Фраза \[$ foo -ge 3 \] возвращает статус завершения, а также два других синтаксиса! Следовательно, есть удобный прием, который вы можете использовать для быстрого тестирования состояния:

```bash
[ $foo -ge 3 ] && echo true
```

В этом примере «echo true» выполняется только в том случае, если `[$ foo -ge 3 ]` возвращает 0 (true). Почему это так, спросите вы? Это потому, что bash оценивает состояние только при необходимости. При использовании комбинирующего выражения _and_ оба условия должны быть истинными, чтобы комбинированное выражение возвращало true. Если первое условие возвращает false, не имеет значения, что возвращает второе; результат будет ложным. Следовательно, bash не оценивает второе условие, и именно поэтому в этом примере «echo true» не выполняется. То же самое относится к оператору _or_ («||»), где второе условие не оценивается, если первое условие истинно.

Что ж, так много для погружения. Если вы хотите узнать еще больше, я хотел бы указать вам на [Руководство по расширенному написанию сценариев](http://www.tldp.org/LDP/abs/html/tests.html "Перейдите в раздел «Тесты» расширенного руководства по написанию сценариев Bash") и, возможно, [Справочное руководство по Bash](http://www.gnu.org/software/bash/manual/bashref.html#Conditional "Конструкции «Прочитайте об условных конструкциях в Справочном руководстве по Bash»") или даже это [Руководство системного администратора по написанию сценариев Bash](https://linuxacademy.com/linux/training/course/name/the-system-administrators-guidep-to-bash-scripting?utm_source=website&utm_medium=blog&utm_campaign=bashblo).
**********
[bash](/tags/bash.md)

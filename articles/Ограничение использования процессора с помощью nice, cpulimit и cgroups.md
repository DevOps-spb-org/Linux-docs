# Ограничение использования процессора с помощью nice, cpulimit и cgroups

### Имитация высокой загрузки процессора

Прежде чем рассматривать эти три метода, нам нужно найти инструмент, который будет моделировать высокую загрузку ЦП в системе. Мы будем использовать CentOS в качестве нашей базовой системы, и для искусственной загрузки процессора мы можем использовать генератор простых чисел из набора инструментов Mathomatic.

Для CentOS нет готового пакета, поэтому вам нужно будет собрать его самостоятельно. Загрузите исходный код с http://mathomatic.orgserve.de/mathomatic-16.0.5.tar.bz2, а затем распакуйте файл архива. Перейдите в каталог **mathomatic-16.0.5/primes**. Запустите **make** и **sudo make install**, чтобы собрать и установить двоичные файлы. Теперь у вас будет бинарный файл **matho-primes** в **/usr/local/bin**.

Запустите команду так:

```bash
/usr/local/bin/matho-primes 0 9999999999 > /dev/null &
```

Это создаст список простых чисел от нуля до девяти миллиардов девятьсот девяносто девять миллионов девятьсот девяносто девять тысяч девятьсот девяносто девять. Поскольку мы действительно не хотим сохранять список, вывод перенаправляется в **/dev/null**.

Теперь запустите top, и вы увидите, что процесс **matho-primes** использует весь доступный процессор.

![](/images/YDXs9CYWSHi0tDZReHFI)

Выйдите из **top** (нажмите клавишу q) и завершите процесс **Мато-штрихи** (**fg**, чтобы вывести процесс на передний план, и нажмите CTRL + C).

### nice

Команда **nice** настраивает уровень приоритета процесса, чтобы он выполнялся реже. Это полезно, когда вам нужно запустить задачу с интенсивным использованием процессора в качестве фонового или пакетного задания. Уровень привлекательности варьируется от -20 (наиболее благоприятный график) до 19 (наименее благоприятный). Процессы в Linux по умолчанию запускаются со значением 0. Команда **nice** (без каких-либо дополнительных параметров) запустит процесс с изящностью 10. На этом уровне планировщик увидит его как задачу с более низким приоритетом и даст ему меньше ресурсов ЦП.

Запустите две задачи с простыми числами: одно с хорошим и одно без:

```bash
nice matho-primes 0 9999999999 > /dev/null &
matho-primes 0 9999999999 > /dev/null &
```

Теперь запустите **топ**.

![](/images/noOl6isSjiqS6ImxiLvm)

Заметьте, что процесс, запущенный без **nice** (на уровне 0), получает больше процессорного времени, а процесс с уровнем 10 - меньше.

В реальном выражении это означает, что если вы хотите запустить задачу, интенсивно использующую процессор, вы можете запустить ее, используя команду **nice**, и планировщик всегда будет гарантировать, что другие задачи имеют приоритет над ней. Это означает, что сервер (или настольный компьютер) будет реагировать даже при большой нагрузке.

У **nice** есть связанная команда, называемая **renice**. Это изменяет уровень привлекательности уже запущенного процесса. Чтобы его использовать, узнайте PID процесса, занимающего все процессорное время (используя **ps**), а затем запустите renice:

```bash
renice +10 1234
```

Где 1234 - это PID.

Не забудьте убить процессы **matho-primes**, как только вы закончите экспериментировать с командами **nice** и **renice**.

### cpulimit

Инструмент **cpulimit** ограничивает использование процессором процесса, останавливая процесс через различные интервалы времени, чтобы удерживать его под определенным потолком. Это делается путем отправки сигналов **SIGSTOP** и **SIGCONT** процессу. Он не меняет полезную ценность процесса, он контролирует и контролирует реальное использование процессора.

**cpulimit** полезен, когда вы хотите убедиться, что процесс использует не более определенной части процессора. Недостатком по сравнению с **nice** является то, что процесс не может использовать все доступное время процессора, когда система простаивает.

Чтобы установить его на CentOS типа:

```bash
wget -O cpulimit.zip https://github.com/opsengine/cpulimit/archive/master.zip
unzip cpulimit.zip
cd cpulimit-master
make
sudo cp src/cpulimit /usr/bin
```

Приведенные выше команды загрузят исходный код из GitHub, распакуют файл архива, соберут двоичный файл и скопируют его в **/usr/bin**.

**cpulimit** используется аналогично **nice**, однако вам нужно явно определить максимальное ограничение ЦП для процесса, используя параметр «-l». Например:

```bash
cpulimit -l 50 matho-primes 0 9999999999 > /dev/null &
```

![](/images/ZGPMohnLTFmYshntAepX)

Обратите внимание, что процесс **matho-primes** теперь использует только 50% доступного процессорного времени. В моем примере система все остальное время проводит в режиме ожидания.

Вы также можете ограничить запущенный в данный момент процесс, указав его PID с помощью параметра «-p». Например

```bash
cpulimit -l 50 -p 1234
```

Где 1234 - PID процесса.

### cgroups

Контрольные группы (**cgroups**) - это функция ядра Linux, которая позволяет вам указать, как ядро должно выделять определенные ресурсы группе процессов. С помощью **cgroups** вы можете указать, сколько процессорного времени, системной памяти, пропускной способности сети или комбинаций этих ресурсов может использоваться процессами, находящимися в определенной группе.

Преимущество контрольных групп перед **nice** или **cpulimit** заключается в том, что ограничения применяются к набору процессов, а не только к одному. Кроме того, **nice** или **cpulimit** ограничивают использование процессора только процессом, тогда как **cgroups** может ограничивать другие ресурсы процесса.

Разумно используя **cgroups**, можно управлять ресурсами целых подсистем сервера. Например, в **CoreOS**, минимальном дистрибутиве **Linux**, предназначенном для массовых развертываний серверов, процессы обновления контролируются **cgroup**. Это означает, что загрузка и установка системных обновлений не влияет на производительность системы.

Чтобы продемонстрировать **cgroups**, мы создадим две группы с разными ресурсами ЦП, выделенными для каждой группы. Группы будут называться "**cpulimited**" и "**lesscpulimited**"

Группы создаются с помощью команды **cgcreate**:

```bash
sudo cgcreate -g cpu:/cpulimited
sudo cgcreate -g cpu:/lesscpulimited
```

Часть команды **-g cpu** говорит команде, что группы могут устанавливать ограничения на количество ресурсов ЦП, предоставляемых процессам в группа. Другие контроллеры включают в себя **cpuset**, **memory** и **blkio**. Контроллер **cpuset** связан с контроллером cpu в том смысле, что он позволяет процессам в группе связываться с конкретным процессором или набором ядер в процессоре.

Контроллер процессора имеет свойство, известное как **cpu.shares**. Оно используется ядром для определения доли ресурсов ЦП, доступных каждому процессу через **cgroups**. Значение по умолчанию - **1024**. Оставляя одну группу (**lesscpulimited**) по умолчанию **1024** и устанавливая другую (**cpulimited**) равной **512**, мы говорим ядру разделить ресурсы ЦП с соотношением **2:1**.

Чтобы установить для **cpu.shares** значение **512** в группе **cpulimited**, введите:

```bash
sudo cgset -r cpu.shares=512 cpulimited
```

Чтобы запустить задачу в определенной группе, вы можете использовать команду **cgexec**. Чтобы проверить две **cgroups**, запустите **matho-primes** в группе **cpulimited**, например так:

```bash
sudo cgexec -g cpu:cpulimited /usr/local/bin/matho-primes 0 9999999999 > /dev/null &
```

Если вы запустите **top**, вы увидите, что процесс занимает все доступное время процессора.

![](/images/sKT7AvBgQiNOQbmQlC3I)

Это связано с тем, что когда выполняется один процесс, он использует столько ЦП, сколько необходимо, независимо от того, в какую **cgroup**. Ограничение ЦП вступает в силу только тогда, когда два или более процесса конкурируют за ресурсы ЦП.

Теперь запустите второй процесс **matho-primes**, на этот раз в группе **lesscpulimited**:

```bash
sudo cgexec -g cpu:lesscpulimited /usr/local/bin/matho-primes 0 9999999999 > /dev/null &
```

Команда **top** показывает, что процесс в **cgroup** с большим значением **cpu.shares** получает больше процессорного времени.

![](/images/WwCWzpYNQ0OkrKavZjO9)

Теперь запустите другой процесс **matho-primes** в группе **cpulimited**:

```bash
sudo cgexec -g cpu:cpulimited /usr/local/bin/matho-primes 0 9999999999 > /dev/null &
```

![](/images/Zg6HmX74RW9AoyR5N1ac)

Обратите внимание на то, как ЦП все еще пропорционален в соотношении **2:1**. Теперь две задачи **matho-primes** в группе **cpulimited** совместно используют центральный процессор, в то время как процесс в другой группе все еще получает больше процессорного времени.
**********
[CentOS](/tags/CentOS.md)
[nice](/tags/nice.md)
[cpulimit](/tags/cpulimit.md)
[cgroups](/tags/cgroups.md)

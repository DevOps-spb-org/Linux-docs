# Можно ли использовать косую черту в имени файла?

Ответ в том, что вы не можете, если в вашей файловой системе нет ошибки. Вот почему:

Существует системный вызов для переименования вашего файла, определенный в `fs/namei.c` и называемый` renameat`:

```
SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname)
```

Когда системный вызов вызывается, он выполняет поиск пути (`do_path_lookup`) по имени. Продолжаем отслеживать это, и мы получаем `link_path_walk`, который имеет это:

```
    static int link_path_walk(const char *name, struct nameidata *nd)
    {
           struct path next;
           int err;
           unsigned int lookup_flags = nd->flags;
    
           while (*name=='/')
                  name++;
           if (!*name)
                  return 0;
    ...
```

Этот код применяется к любой файловой системе. Что это значит? Это означает, что если вы попытаетесь передать параметр с реальным символом `/` в качестве имени файла, используя традиционные средства, он не будет делать то, что вы хотите. Нет способа экранировать символ. Если файловая система «поддерживает» это, это потому, что они либо:

* Используйте символ Unicode или что-то похожее на косую черту, но это не так.
* У них есть ошибка.

Кроме того, если вы зайдете и отредактируете байты, добавив символ косой черты в имя файла, могут произойти плохие вещи. Это потому, что вы никогда не сможете ссылаться на этот файл по имени :(, поскольку в любое время Linux предполагал, что вы ссылаетесь на несуществующий каталог. Использование метода `rm \ *` также не будет работать, поскольку bash просто расширяет его до имени файла. Даже `rm -rf` не сработает, так как простая строка показывает, как все происходит под капотом (сокращенно):

```console
$ ls testdir
myfile2 out
$ strace -vf rm -rf testdir
...
unlinkat(3, "myfile2", 0)               = 0
unlinkat(3, "out", 0)                   = 0
fcntl(3, F_GETFD)                       = 0x1 (flags FD_CLOEXEC)
close(3)                                = 0
unlinkat(AT_FDCWD, "testdir", AT_REMOVEDIR) = 0
...
```

Обратите внимание, что эти вызовы `unlinkat` не будут выполнены, потому что они должны ссылаться на файлы по имени.
**********
[файловая система](/tags/%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0.md)

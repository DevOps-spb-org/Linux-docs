# Форкинг против потоков

Итак, наконец, после долгого времени, я могу понять разницу между разветвлением и многопоточностью :)

Когда я занимаюсь серфингом, я вижу множество тем / вопросов, касающихся разветвления и многопоточности, множество запросов, которые следует использовать в приложениях. Итак, я написал этот пост, который мог бы прояснить разницу между этими двумя, основываясь на том, что вы можете решить, что вы хотите использовать в своем приложении/скриптах.

### Что такое Форк/Forking:

Fork - это не что иное, как новый процесс, который выглядит точно так же, как старый или родительский процесс, но все же это другой процесс с другим идентификатором процесса и собственной памятью. Родительский процесс создает отдельное адресное пространство для дочернего. И родительский, и дочерний процессы имеют один и тот же сегмент кода, но выполняются независимо друг от друга.

Самый простой пример разветвления - это когда вы запускаете команду на оболочке в unix / linux. Каждый раз, когда пользователь вводит команду, оболочка разветвляет дочерний процесс, и задача выполняется.

Когда выполняется системный вызов fork, создается копия всех страниц, соответствующих родительскому процессу, загружаемая ОС в отдельную область памяти для дочернего процесса, но в некоторых случаях это не требуется. Как и в системных вызовах exec, нет необходимости копировать страницы родительского процесса, поскольку execv заменяет адресное пространство самого родительского процесса.

#### Несколько замечаний по поводу разветвления:

* У дочернего процесса будет собственный уникальный идентификатор процесса.
* Дочерний процесс должен иметь собственную копию дескриптора файла родителя.
* Блокировки файлов, установленные родительским процессом, не должны наследоваться дочерним процессом.
* Любые семафоры, которые открыты в родительском процессе, также должны быть открыты в дочернем процессе.
* Дочерний процесс должен иметь собственную копию дескрипторов очереди сообщений родителей.
* У ребенка будет собственное адресное пространство и память.

#### Форк общепризнан чем поток по следующим причинам:

*   Разработка намного проще на реализациях на основе форка.
* Форк-код более удобен в обслуживании.
* Форкинг намного безопаснее и безопаснее, потому что каждый разветвленный процесс выполняется в своем собственном виртуальном адресном пространстве. Если происходит сбой одного процесса или переполнение буфера, это никак не влияет на другие процессы.
* Потоки кода гораздо сложнее отлаживать, чем форк.
* Форки более переносимы, чем нити.
* Форкирование выполняется быстрее, чем многопоточность на одном процессоре, так как отсутствуют блокирующие издержки или переключение контекста.

Некоторые из приложений, в которых используется разветвление: _telnetd(freebsd), vsftpd, proftpd, Apache13, Apache2, thttpd, PostgreSQL._

#### Подводные камни в Форке:

*   В форке каждый новый процесс должен иметь свою собственную память / адресное пространство, следовательно, более длительное время запуска и остановки.
* Если вы разветвляетесь, у вас есть два независимых процесса, которые должны каким-то образом общаться друг с другом. Это межпроцессное взаимодействие действительно дорого.
* Когда родитель выходит перед раздвоенным ребенком, вы получите призрачный процесс. С нитью все гораздо проще. Вы можете легко завершать, приостанавливать и возобновлять потоки от родителя. И если ваш родитель выходит внезапно, поток будет завершен автоматически.
* Недостаточно места для хранения может привести к отказу вилочной системы.

### Что такое потоки:

Нити это облегченные процессы (LWPs - Light Weight Processes). Традиционно, поток просто состояние ЦП (и некоторые другие минимальный государства) с процессом, содержащим остатки (данных, стека, ввода/вывода сигналов). Потоки требуют меньше ресурсов, чем “расщепление” (forking) или порождение нового процесса, поскольку система не инициализирует новую систему виртуальной памяти пространство и среду для этого процесса. В то время как наиболее эффективным на многопроцессорной системы, в которой поток процесса может быть запланирован для выполнения на другом процессоре, таким образом, набирает скорость за счет параллельной или распределенной обработки, приобретает также найдены на однопроцессорных системах, которые используют задержки ввода/вывода и другие функции системы, которые могут остановить процесс выполнения.

#### Потоки одного процесса разделяют:

* Инструкция по процесс 
* Большинство данных
* открытые файлы (дескрипторы)
* сигналы и обработчики сигналов 
* текущий рабочий каталог
* Идентификатор пользователя и группы 

#### Каждый поток имеет уникальный:

* Идентификатор потока 
* набор регистров, указателя стека 
* стеке для локальных переменных, обратные адреса
* маску сигналов
* приоритет
* Возвращаемое значение: значение errno

#### Несколько заметок о потоках:

* Нити наиболее эффективны на многопроцессорных или многоядерных системах.
* Для потока – нужен только один процесс/нить стол и один планировщик.
* Все потоки процесса разделяют адресное пространство.
* Нить не вести список созданных потоков, а также не знаете, что поток, который его создал.
* Нити уменьшить издержки путем обмена основных частей.
* Нити более эффективным в управлении памятью, потому что они использует один и тот же блок памяти родителя, а не создавать новые.

#### Подводные камни в потоках:

*   Условия гонки(Race conditions): большие потери с темы заключается в том, что нет никакой естественной защиты от несколько потоков, работающих на одних и тех же данных одновременно, не зная, что другие с ней возиться. Это называется состоянием состязания. В то время как код может появиться на экране в том порядке, вы хотите, чтобы код для выполнения, потоки предназначены для операционной системы и выполняются в случайном порядке. Нельзя предполагать, что потоки выполняются в порядке их создания. Они могут также выполняться на разных скоростях. Когда потоки выполнения (гонки по полной) они могут привести к неожиданным результатам (состояние гонки). Мьютексы и соединения должны быть использованы для достижения предсказуемого порядка исполнения и результатов.
*   Потокобезопасный код(Thread safe code): Потоковые процедуры должны вызывать функции, которые являются "потокобезопасными". Это означает, что нет никаких статических или глобальных переменных, которые другие потоки могут избить или прочитать предполагая однопоточная операция. Если статические или глобальные переменные используются мьютексы должны быть применены или функции должен быть переписан, чтобы избежать использования этих переменных. В C локальные переменные динамически выделенной на стеке. Таким образом, любая функция, которая не использует статические данные или другие общие ресурсы является потокобезопасным. Поток-опасных функций может быть использован только один поток одновременно в программе и уникальность резьбы должна быть обеспечена. Многие нереентерабельные функции возвращают указатели на статические данные. Этого можно избежать путем возврата динамически выделяемые данные или используя предоставленный вызывающим объектом хранения. Пример не потокобезопасная функция функции strtok, которая тоже не реентерабельна. В “потокобезопасным” версия является реентерабельной версией strtok\_r.

#### Преимущества потоков:

* Потоки используют то же пространство памяти, следовательно, обмен данными между ними действительно быстрее средства межпроцессного взаимодействия (IPC) - это очень быстро.
* Если правильно спроектированная и реализованная потоков даст вам больше скорости, потому что нет рядом какого-либо процесса уровня контекста переключение в многопоточных приложения.
* Потоки очень быстро запускаются и завершаются.

Некоторые из приложений, в которых используются потоки, являются: _MySQL, Firebird, Apache2, MySQL 323_

### Часто задаваемые вопросы:

_1\. Что я должен использовать в моем приложении ?_

Ответ: Это зависит от многих факторов. Форкинг является более тяжелым, чем нарезка, и имеет более высокие затраты на запуск и останов. Межпроцессное взаимодействие (IPC) также сложнее и медленнее, чем межпотоковое взаимодействие. На самом деле потоки действительно выигрывают гонку, когда дело доходит до межобщинного общения. И наоборот, тогда как в случае сбоя потока он удаляет все остальные потоки в процессе, а если поток имеет переполнение буфера, он открывает дыру в безопасности во всех потоках.

который будет использовать одно и то же адресное пространство с родительским процессом, и им потребуется только сокращенное переключение контекста, что сделает переключение контекста более эффективным.

_2\. Какой из них лучше, многопоточность или разветвление?_

Ответ: Это то, что полностью зависит от того, что вы ищете. Еще предстоит ответить: в современном Linux (2.6.x) нет большой разницы в производительности между переключением контекста процесса / разветвления по сравнению с потоком (только поток MMU является дополнительным для потока). Существует проблема с общим адресным пространством, что означает, что неисправный указатель в потоке может повредить память родительского процесса или другого потока в том же адресном пространстве.

_3\. Какие вещи должны быть многопоточными или многопоточными?_

Ответ: Если вы программист и хотели бы воспользоваться преимуществами многопоточности, естественный вопрос заключается в том, какие части программы должны / не должны быть пронизаны. Вот несколько практических правил (если вы скажете «да», получайте удовольствие!):

* Существуют ли группы длительных операций, которые необязательно зависят от другой обработки (например, рисование окна, печать документа, реагирование на щелчок мыши, вычисление столбца электронной таблицы, обработка сигнала и т. Д.)?
* Будет ли несколько блокировок данных (количество общих данных идентифицируемо и «мало»)?
* Готовы ли вы беспокоиться о блокировке (взаимно исключая области данных из других потоков), взаимоблокировках (состояние, при котором два COE заблокировали данные, которые пытается получить другой), и условиях гонки (неприятная, неразрешимая проблема, когда данные не блокируются должным образом и поврежден из-за чтения и записи в потоке)?
* Может ли задача быть разбита на различные «обязанности»? Например. Может ли один поток обрабатывать сигналы, другой обрабатывать GUI и т. Д.?

## Выводы:

1. Нужно ли вам использовать многопоточность или разветвление, полностью зависит от требований вашего приложения.
2. Потоки более мощные, чем события, но мощность - это не то, что всегда нужно.
3. Потоки гораздо сложнее программировать, чем разветвление, поэтому только для экспертов.
4. Используйте потоки в основном для приложений, критичных к производительности.

## References:

1.  [http://en.wikipedia.org/wiki/Fork\_(operating\_system)](http://www.geekride.com/fork-forking-vs-threading-thread-linux-kernel/#%20http://en.wikipedia.org/wiki/Fork_(operating_system))
2.  [http://tldp.org/FAQ/Threads-FAQ/Comparison.html](http://tldp.org/FAQ/Threads-FAQ/Comparison.html)
3.  [http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html](http://www.geekride.com/fork-forking-vs-threading-thread-linux-kernel/#%20http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html)
4.  [http://linas.org/linux/threads-faq.html](http://www.geekride.com/fork-forking-vs-threading-thread-linux-kernel/#%20http://linas.org/linux/threads-faq.html)


http://www.geekride.com/fork-forking-vs-threading-thread-linux-kernel/

**********
[fork](/tags/fork.md)
[thread](/tags/thread.md)

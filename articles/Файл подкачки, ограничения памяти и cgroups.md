# Файл подкачки, ограничения памяти и cgroups

https://jvns.ca/blog/2017/02/17/mystery-swap/

На этой неделе на работе произошла ошибка, и я узнал что-то новое о памяти, обмене и группах!

Понимание того, как работает использование памяти, уже некоторое время является постоянным проектом - еще в декабре я написал [Сколько памяти использует мой процесс?](Https://jvns.ca/blog/2016/12/03/how-much-memory-is-my-process-using-/), который объясняет, как работает память в Linux.

Поэтому вчера я был удивлен и обеспокоен, когда с Linux что-то происходит с памятью, чего я не понимаю! Вот ситуация и почему я был сбит с толку:

У нас было несколько машин, на которых работали сборки. Они менялись местами. Они сказали 30 ГБ ОЗУ в общей сложности. 15 ГБ использовались некоторыми процессами, а 15 ГБ - кешем файловой системы. Я был действительно смущен тем, почему эти машины менялись местами, потому что - я знаю о памяти! Если кеш файловой системы использует 15 ГБ памяти, ОС всегда может освободить эту память! Там нет причин для обмена!

Затем я узнал о параметре «swappiness» и о том, что, если «swappiness» является высоким, то ОС, будет использовать swap, даже если в этом нет особой необходимости. Мы попытались установить `sysctl vm.swappiness = 1`, что позволит вам сказать операционной системе: «Нет, действительно, пожалуйста, не используй swap, просто вместо этого удали память из кэша файловой системы». Машина продолжала использовать swap. Я был сбит с толку.

Через некоторое время мы отключили «своп» и все стало еще хуже. Некоторые процессы стали убиваться OOM. (OOM killer в Linux убьет процессы, если у вас не хватит памяти) Но почему? У боксов была свободная память, не так ли? У меня в голове была аксиома «если у компьютера есть свободная память, нет причин, по которым процессы на нем должны быть убиты OOM». Очевидно, было что-то, чего я не понял.

Наконец, я посмотрел на вывод `dmesg` (именно так вы видите сообщения, которые печатает ядро Linux о том, что он задумал), чтобы понять, почему процессы были уничтожены OOM. А потом появилось это волшебное слово: `cgroups`. Все стало понятно довольно быстро:

*   процессы, которые были убиты, были в cgroup (о которой мы говорили в этом [пространства имен и группы](https://jvns.ca/blog/2016/10/10/what-even-is-a-container/) посте)
*   cgroups может иметь **ограничения памяти**, которые похожи на «вам разрешено использовать только 15 ГБ памяти, иначе ваши процессы будут убиты OOM килером»
*   и этот предел памяти был причиной того, что процессы были убиты, даже если была свободная память!

### swap + cgroup ограничения памяти = сюрпризы

Моя модель пределов памяти для cgroups всегда была «если вы используете больше памяти, чем X, вы сразу же будете убиты». Оказывается, это предположение было неверным! Если вы используете больше памяти X, вы все равно можете использовать swap!

И, видимо, некоторые ядра также поддерживают установку отдельных ограничений файла подкачки. Таким образом, вы можете установить предел памяти в X и предел файла подкачки в 0, что даст вам более предсказуемое поведение. Файл подкачки - это странно и сбивает с толку.

Во всяком случае, благодаря всему этому мы выяснили, что рассматриваемые процессы недавно начали использовать гораздо больше памяти по вполне понятным причинам, и откатили это изменение, и все снова имело смысл.

И что более важно, чем все, что имело смысл, система сборки снова была счастлива.

### своп вообще имеет смысл?

Мне не совсем понятно, при каких обстоятельствах вообще имеет смысл иметь «своп» на компьютере. Кажется, что «своп» играет определенную роль на настольных компьютерах.

Я не уверен, что если какой-либо из серверов, с которыми мы работаем, выигрывает от включения свопинга? Кажется, это было бы хорошо понять.

Как будто я слышу совет «нет, просто всегда отключайте «своп», это будет лучше в целом», и, возможно, это правильно! Я думаю, что причина, по которой «своп» считается плохим в производственных системах, заключается в том, что он имеет странные/непредсказуемые эффекты, а предсказуемость - это хорошо.

В некоторой степени, эта статья [swap insanity](https://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/) выглядит действительно интересной.

### понимание моделей памяти это круто

Я научился

* vm.swappiness существует, и вы можете использовать его для более или менее вероятного использования файла подкачки компьютера
* что, когда Linux OOM убивает процесс в cgroup («контейнер»), он на самом деле печатает кучу очень полезных вещей об использовании памяти всего остального в cgroup в то время. Я должен помнить, чтобы посмотреть в dmesg ранее!

Для меня очень важно понять, что происходит на компьютерах, с которыми я работаю, - когда что-то происходит, например, - этот компьютер подменяется, и я не знаю, ПОЧЕМУ, это меня сильно беспокоит.

Теперь, если я когда-нибудь увижу процесс таинственного обмена, надеюсь, я буду помнить об ограничении памяти!


**********
[swap](/tags/swap.md)
[cgroups](/tags/cgroups.md)
[память](/tags/%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C.md)
